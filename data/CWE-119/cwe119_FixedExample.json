[
    {
        "example_id": "DX-1",
        "fixed_code": "{\n\"void host_lookup(char *user_supplied_addr){\\n\\tstruct hostent *hp;\\n\\tin_addr_t *addr;\\n\\tchar hostname[64];\\n\\tin_addr_t inet_addr(const char *cp);\\n\" \n   \"validate_addr_form(user_supplied_addr);\\n\\taddr = inet_addr(user_supplied_addr);\\n\\tif (addr == INADDR_NONE)\\n\\t{\\n\\t\\t\\t/* Handle Error */\\n\\t}\\n\\thp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\\n\\tif (hp == NULL)\\n\\t{\\n\\t\\t/* Handle Error */\\n\\t}\\n\\tstrncpy(hostname, hp->h_name, sizeof(hostname)-1);\\n\\thostname[sizeof(hostname)-1] = '\\0';\\n}\"}",
        "description": "{\"The vulnerability in the code lies in the fact that no checks are implemented to ensure that the hostname won't exceed the allocated buffer of 64 bytes. An attacker could potentially provide an address that resolves to a hostname longer than 64 bytes, leading to a buffer overflow and potentially causing the program to overwrite sensitive data or relinquish control to the attacker. Moreover, the original code does not check the return value of the gethostbyaddr and inet_addr functions, which can lead to a NULL pointer dereference if the functions fail.\\n\\nTo fix these issues, a condition is added after calling the inet_addr function to check if the return value is INADDR_NONE, signifying an error, in which the error is then managed appropriately. A similar check is added after calling the gethostbyaddr function.\\n\\nIn addition, to protect against buffer overflow, the strncpy function is used instead of strcpy when copying the hostname. This function takes an extra parameter specifying the maximum number of characters to be copied. By copying only up to sizeof(hostname) - 1 characters, ensuring there's room left for the null terminator, the vulnerability to buffer overflow attacks is addressed. The last character is explicitly set to null to be sure that the string is null-terminated, even if the source string was longer than the buffer.}\"}"
    },
    {
        "example_id": "DX-19",
        "fixed_code": "\"char * copy_input(char *user_supplied_string){\\n\\tint i, dst_index;\\n\\tint len = strlen(user_supplied_string);\\n\\tchar *dst_buf = (char*)malloc(5*sizeof(char) * len);\\n\\tif ( len > MAX_SIZE ){\\n\\t\\tdie(\\\"user string too long, die evil hacker!\\\");\\n\\t}\\n\\tdst_index = 0;\\n\\tfor ( i = 0; i < len; i++ ){\\n\\t\\tif( '&' == user_supplied_string[i] ){\\n\\t\\t\\tdst_buf[dst_index++] = '&';\\n\\t\\t\\tdst_buf[dst_index++] = 'a';\\n\\t\\t\\tdst_buf[dst_index++] = 'm';\\n\\t\\t\\tdst_buf[dst_index++] = 'p';\\n\\t\\t\\tdst_buf[dst_index++] = ';';\\n\\t\\t}\\n\\t\\telse if ('<' == user_supplied_string[i] ){\\n\\t\\t\\t/* encode to &lt; */\\n\\t\\t}\\n\\t\\telse dst_buf[dst_index++] = user_supplied_string[i];}\\n\\treturn dst_buf;\\n}\"",
        "description": "\"The vulnerability in the original code was a buffer overflow potential caused by two factors: (1) the length of the user-supplied string was being checked before the encoding operation was applied, and (2) the encoding operation expanded the length of the string longer than the size allocated for the destination buffer. Buffer overflow issues can allow an attacker to write arbitrary data to memory, leading to unpredictable behavior, potentially including code execution.\\n\\nIn the fixed version of the code, I've modified it to handle these issues by first calculating the length of the string, then allocating memory for the destination buffer taking into account the maximum possible encoding expansion (by factor of 5 for the '&' character). After that we check if the length of the user supplied string is more than MAX_SIZE. If it is, we terminate execution. This prevents any buffer overflow potential, because sufficient space is ensured for the encoded version of the input.\""
    },
    {
        "example_id": "DX-90",
        "fixed_code": "{\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint main (int argc, char **argv) {\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tchar *items[] = {\\\"boat\\\", \\\"car\\\", \\\"truck\\\", \\\"train\\\"};\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint index = GetUntrustedOffset();\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (index >= 1 && index <= 4) \\{\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tprintf(\\\"You selected %s\\\\n\\\", items[index-1]);\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\}\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse \\{\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tprintf(\\\"Invalid option. Please select a valid one.\\\\n\\\");\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\}\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}",
        "description": "In the provided code, the user-input offset value is directly used to index the items array without any boundary checks. Thus, if a user provides an offset that is out of the array's bounds, a buffer over-read occurs, which could result in undefined behavior and potentially expose sensitive information.\\r\\n\\r\\nMy fix addresses this by including a condition to check whether a provided offset value is within the bounds of the array's indices. This is done using a simple If-Else condition to restrict the index from 1 to 4 (i.e. the number of elements in the items[] array). If the input offset doesn't fall within this range, an 'Invalid option' message will display and prevent the buffer over-read."
    },
    {
        "example_id": "DX-100",
        "fixed_code": "int getValueFromArray(int *array, int len, int index) {\\n\\tint value;\\n\\tif (index >= 0 && index < len) {\\n\\t\\tvalue = array[index];\\n\\t} else {\\n\\t\\tprintf(\"Invalid array index - %d\\n\", index);\\n\\t\\tvalue = -1;\\n\\t}\\n\\treturn value;\\n}",
        "description": "The original code was vulnerable to out of bounds read (CWE-125) due to inadequate check for the array index value. This could allow access to sensitive memory if an attacker provides a negative index value. The vulnerability is due to the fact that the index validation step only checks if the index is less than the maximum length of the array but fails to check if the index is negative or greater than or equal to zero. The fixed code introduces a check to ensure the index is non-negative as well as less than the length of the array. This provides an accurate range validation and prevents access to out of bounds memory, thereby fixing CWE-839 and CWE-129 vulnerabilities."
    },
    {
        "example_id": "GEN-5",
        "fixed_code": "{\\r\\n  CHAR szMultiByte[256];\\r\\n  size_t len = strlen(szMultiByte);\\r\\n  CHAR * copy = (CHAR *) malloc(len + 1);\\r\\n  if (copy) {\\r\\n    strcpy_s(copy, len + 1, szMultiByte);\\r\\n    CHAR * result = _mbsinc((const unsigned char *)copy);\\r\\n    if (result) {\\r\\n      // process result\\r\\n    }\\r\\n    free(copy);\\r\\n  }\\r\\n  else {\\r\\n    // handle error\\r\\n  }\\r\\n}",
        "description": "The vulnerability in the original code lies in the potential for a buffer overflow, due to the use of the _mbsinc function on potentially malformed multibyte strings, directly on the original string buffer. This can happen when a string contains a valid leading byte followed by a null byte, causing the function to read or write past the end of the string buffer. To mitigate this risk, the fixed code first checks the length of the multibyte input string, then allocates a new buffer of appropriate size. The input string is copied to this new buffer using the secure strcpy_s function before _mbsinc is used. This ensures that any malfunction caused by _mbsinc would not result in a buffer overflow, as it would only affect the copied buffer, which has been specially allocated for this operation."
    }
]