cwe_id,example_id,entry_order,IntroText,Nature,Language,ExampleCode,BodyText
119,DX-1,1,"This example takes an IP address from a user, verifies that it is well formed and then looks up the hostname and copies it into a buffer.",NULL,NULL,NULL,NULL
119,DX-1,2,NULL,Bad,C,"```
	void host_lookup(char *user_supplied_addr){
			struct hostent *hp;
			in_addr_t *addr;
			char hostname[64];
			in_addr_t inet_addr(const char *cp);
```
/*routine that ensures user_supplied_addr is in the right format for conversion */* 
			
			validate_addr_form(user_supplied_addr);
			addr = inet_addr(user_supplied_addr);
			hp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);
			strcpy(hostname, hp->h_name);}",NULL
119,DX-1,3,NULL,NULL,NULL,NULL,"This function allocates a buffer of 64 bytes to store the hostname, however there is no guarantee that the hostname will not be larger than 64 bytes. If an attacker specifies an address which resolves to a very large hostname, then the function may overwrite sensitive data or even relinquish control flow to the attacker."
119,DX-1,4,NULL,NULL,NULL,NULL,Note that this example also contains an unchecked return value (CWE-252) that can lead to a NULL pointer dereference (CWE-476).
119,DX-19,1,This example applies an encoding procedure to an input string and stores it into a buffer.,NULL,NULL,NULL,NULL
119,DX-19,2,NULL,Bad,C,"```
	char * copy_input(char *user_supplied_string){
			int i, dst_index;
			char *dst_buf = (char*)malloc(4*sizeof(char) * MAX_SIZE);
			if ( MAX_SIZE <= strlen(user_supplied_string) ){
				die(""user string too long, die evil hacker!"");
			}
			dst_index = 0;
			for ( i = 0; i < strlen(user_supplied_string); i++ ){
					if( '&' == user_supplied_string[i] ){
						dst_buf[dst_index++] = '&';
						dst_buf[dst_index++] = 'a';
						dst_buf[dst_index++] = 'm';
						dst_buf[dst_index++] = 'p';
						dst_buf[dst_index++] = ';';
					}
					else if ('<' == user_supplied_string[i] ){
```
/* encode to &lt; */* 
						}
					else dst_buf[dst_index++] = user_supplied_string[i];}
			return dst_buf;}",NULL
119,DX-19,3,NULL,NULL,NULL,NULL,"The programmer attempts to encode the ampersand character in the user-controlled string, however the length of the string is validated before the encoding procedure is applied. Furthermore, the programmer assumes encoding expansion will only expand a given character by a factor of 4, while the encoding of the ampersand expands by 5. As a result, when the encoding procedure expands the string it is possible to overflow the destination buffer if the attacker provides a string of many ampersands."
119,DX-90,1,The following example asks a user for an offset into an array to select an item.,NULL,NULL,NULL,NULL
119,DX-90,2,NULL,Bad,C,"```
	int main (int argc, char **argv) {
		char *items[] = {""boat"", ""car"", ""truck"", ""train""};
		int index = GetUntrustedOffset();
		printf(""You selected %s\n"", items[index-1]);
	}
```",NULL
119,DX-90,3,NULL,NULL,NULL,NULL,"The programmer allows the user to specify which element in the list to select, however an attacker can provide an out-of-bounds offset, resulting in a buffer over-read (CWE-126)."
119,DX-100,1,"In the following code, the method retrieves a value from an array at a specific array index location that is given as an input parameter to the method",NULL,NULL,NULL,NULL
119,DX-100,2,NULL,Bad,C,"```
	int getValueFromArray(int *array, int len, int index) {
			int value;
```
// check that the array index is less than the maximum* 
			
			
			 *// length of the array* 
			if (index < len) {
			```
```
// get the value at the specified index of the array* 
					value = array[index];}
			
			 *// if array index is invalid then output error message* 
			
			 *// and return value indicating error* 
			else {
			```
				printf(""Value is: %d\n"", array[index]);
				value = -1;
			}
			return value;
	}
```",NULL
119,DX-100,3,NULL,NULL,NULL,NULL,"However, this method only verifies that the given array index is less than the maximum length of the array but does not check for the minimum value (CWE-839). This will allow a negative value to be accepted as the input array index, which will result in a out of bounds read (CWE-125) and may allow access to sensitive memory. The input array index should be checked to verify that is within the maximum and minimum range required for the array (CWE-129). In this example the if statement should be modified to include a minimum range check, as shown below."
119,DX-100,4,NULL,Good,C,"```
	...
```
// check that the array index is within the correct* 
	
	
	 *// range of values for the array* 
	if (index >= 0 && index < len) {
	
	...",NULL
119,GEN-5,1,"Windows provides the _mbs family of functions to perform various operations on multibyte strings. When these functions are passed a malformed multibyte string, such as a string containing a valid leading byte followed by a single null byte, they can read or write past the end of the string buffer causing a buffer overflow. The following functions all pose a risk of buffer overflow: _mbsinc _mbsdec _mbsncat _mbsncpy _mbsnextc _mbsnset _mbsrev _mbsset _mbsstr _mbstok _mbccpy _mbslen",NULL,NULL,NULL,NULL
