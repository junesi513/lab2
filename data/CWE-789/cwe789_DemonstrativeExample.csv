cwe_id,example_id,entry_order,IntroText,Nature,Language,ExampleCode,BodyText
789,GEN-1,1,"Consider the following code, which accepts an untrusted size value and allocates a buffer to contain a string of the given size.",NULL,NULL,NULL,NULL
789,GEN-1,2,NULL,Bad,C,"```
	unsigned int size = GetUntrustedInt();
```
/* ignore integer overflow (CWE-190) for this example */* 
	
	unsigned int totBytes = size * sizeof(char);
	char *string = (char *)malloc(totBytes);
	InitializeString(string);",NULL
789,GEN-1,3,NULL,NULL,NULL,NULL,Suppose an attacker provides a size value of:
789,GEN-1,4,NULL,NULL,NULL,NULL,``` 12345678 ```
789,GEN-1,5,NULL,NULL,NULL,NULL,"This will cause 305,419,896 bytes (over 291 megabytes) to be allocated for the string."
789,GEN-2,1,"Consider the following code, which accepts an untrusted size value and uses the size as an initial capacity for a HashMap.",NULL,NULL,NULL,NULL
789,GEN-2,2,NULL,Bad,Java,"```
	unsigned int size = GetUntrustedInt();
	HashMap list = new HashMap(size);
```",NULL
789,GEN-2,3,NULL,NULL,NULL,NULL,"The HashMap constructor will verify that the initial capacity is not negative, however there is no check in place to verify that sufficient memory is present. If the attacker provides a large enough value, the application will run into an OutOfMemoryError."
789,DX-137,1,This code performs a stack allocation based on a length calculation.,NULL,NULL,NULL,NULL
789,DX-137,2,NULL,Bad,C,"```
	 int a = 5, b = 6;
	 size_t len = a - b;
	 char buf[len]; // Just blows up the stack 
 }
```",NULL
789,DX-137,3,NULL,NULL,NULL,NULL,"Since a and b are declared as signed ints, the ""a - b"" subtraction gives a negative result (-1). However, since len is declared to be unsigned, len is cast to an extremely large positive number (on 32-bit systems - 4294967295). As a result, the buffer buf[len] declaration uses an extremely large size to allocate on the stack, very likely more than the entire computer's memory space."
789,DX-137,4,NULL,NULL,NULL,NULL,Miscalculations usually will not be so obvious. The calculation will either be complicated or the result of an attacker's input to attain the negative value.
789,DX-138,1,This example shows a typical attempt to parse a string with an error resulting from a difference in assumptions between the caller to a function and the function's action.,NULL,NULL,NULL,NULL
789,DX-138,2,NULL,Bad,C,"int proc_msg(char *s, int msg_len)
 {

```
```
// Note space at the end of the string - assume all strings have preamble with space* 
	 int pre_len = sizeof(""preamble: "");
	 char buf[pre_len - msg_len];
	
	 *... Do processing here if we get this far*  }
 char *s = ""preamble: message\n"";
 char *sl = strchr(s, ':'); // Number of characters up to ':' (not including space)
 int jnklen = sl == NULL ? 0 : sl - s; // If undefined pointer, use zero length
 int ret_val = proc_msg (""s"", jnklen); // Violate assumption of preamble length, end up with negative value, blow out stack",NULL
789,DX-138,3,NULL,NULL,NULL,NULL,"The buffer length ends up being -1, resulting in a blown out stack. The space character after the colon is included in the function calculation, but not in the caller's calculation. This, unfortunately, is not usually so obvious but exists in an obtuse series of calculations."
789,GEN-5,1,The following code obtains an untrusted number that is used as an index into an array of messages.,NULL,NULL,NULL,NULL
789,GEN-5,2,NULL,Bad,Perl,"```
	my $num = GetUntrustedNumber();
	my @messages = ();
	$messages[$num] = ""Hello World"";
```",NULL
789,GEN-5,3,NULL,NULL,NULL,NULL,"The index is not validated at all (CWE-129), so it might be possible for an attacker to modify an element in @messages that was not intended. If an index is used that is larger than the current size of the array, the Perl interpreter automatically expands the array so that the large index works."
789,GEN-5,4,NULL,NULL,NULL,NULL,"If $num is a large value such as 2147483648 (1<<31), then the assignment to $messages[$num] would attempt to create a very large array, then eventually produce an error message such as:"
789,GEN-5,5,NULL,NULL,NULL,NULL,Out of memory during array extend
789,GEN-5,6,NULL,NULL,NULL,NULL,"This memory exhaustion will cause the Perl program to exit, possibly a denial of service. In addition, the lack of memory could also prevent many other programs from successfully running on the system."
789,GEN-6,1,"This example shows a typical attempt to parse a string with an error resulting from a difference in assumptions between the caller to a function and the function's action. The buffer length ends up being -1 resulting in a blown out stack. The space character after the colon is included in the function calculation, but not in the caller's calculation. This, unfortunately, is not usually so obvious but exists in an obtuse series of calculations.",NULL,NULL,NULL,NULL
789,GEN-6,2,NULL,Bad,C,"int proc_msg(char *s, int msg_len)
 {

```
	int pre_len = sizeof(""preamble: ""); // Note space at the end of the string - assume all strings have preamble with space
	char buf[pre_len - msg_len];
	... Do processing here and set status
	return status;
 } 
 char *s = ""preamble: message\n"";
 char *sl = strchr(s, ':'); // Number of characters up to ':' (not including space)
 int jnklen = sl == NULL ? 0 : sl - s; // If undefined pointer, use zero length
 int ret_val = proc_msg (""s"", jnklen); // Violate assumption of preamble length, end up with negative value, blow out stack
```",NULL
789,GEN-6,3,NULL,Good,C,"int proc_msg(char *s, int msg_len)
 {

```
	int pre_len = sizeof(""preamble: ""); // Note space at the end of the string - assume all strings have preamble with space
	if (pre_len <= msg_len) { // Log error; return error_code; }
	char buf[pre_len - msg_len];
	... Do processing here and set status
	return status;
 } 
 char *s = ""preamble: message\n"";
 char *sl = strchr(s, ':'); // Number of characters up to ':' (not including space)
 int jnklen = sl == NULL ? 0 : sl - s; // If undefined pointer, use zero length
 int ret_val = proc_msg (""s"", jnklen); // Violate assumption of preamble length, end up with negative value, blow out stack
```",NULL
