cwe_id,example_id,entry_order,IntroText,Nature,Language,ExampleCode,BodyText
807,DX-15,1,The following code excerpt reads a value from a browser cookie to determine the role of the user.,NULL,NULL,NULL,NULL
807,DX-15,2,NULL,Bad,Java,"```
	Cookie[] cookies = request.getCookies();
	for (int i =0; i< cookies.length; i++) {
		Cookie c = cookies[i];
		if (c.getName().equals(""role"")) {
			userRole = c.getValue();
		}
	}
```",NULL
807,DX-16,1,The following code could be for a medical records application. It performs authentication by checking if a cookie has been set.,NULL,NULL,NULL,NULL
807,DX-16,2,NULL,Bad,PHP,"```
	$auth = $_COOKIES['authenticated'];
	if (! $auth) {
		if (AuthenticateUser($_POST['user'], $_POST['password']) == ""success"") {
			// save the cookie to send out in future responses
			setcookie(""authenticated"", ""1"", time()+60*60*2);
		}
		else {
			ShowLoginScreen();
			die(""\n"");
		}
	}
	DisplayMedicalHistory($_POST['patient_ID']);
```",NULL
807,DX-16,3,NULL,NULL,NULL,NULL,"The programmer expects that the AuthenticateUser() check will always be applied, and the ""authenticated"" cookie will only be set when authentication succeeds. The programmer even diligently specifies a 2-hour expiration for the cookie."
807,DX-16,4,NULL,NULL,NULL,NULL,"However, the attacker can set the ""authenticated"" cookie to a non-zero value such as 1. As a result, the $auth variable is 1, and the AuthenticateUser() check is not even performed. The attacker has bypassed the authentication."
807,DX-17,1,"In the following example, an authentication flag is read from a browser cookie, thus allowing for external control of user state data.",NULL,NULL,NULL,NULL
807,DX-17,2,NULL,Bad,Java,"```
	Cookie[] cookies = request.getCookies();
	for (int i =0; i< cookies.length; i++) {
		Cookie c = cookies[i];
		if (c.getName().equals(""authenticated"") && Boolean.TRUE.equals(c.getValue())) {
			authenticated = true;
		}
	}
```",NULL
807,DX-93,1,"The following code samples use a DNS lookup in order to decide whether or not an inbound request is from a trusted host. If an attacker can poison the DNS cache, they can gain trusted status.",NULL,NULL,NULL,NULL
807,DX-93,2,NULL,Bad,C,"```
	struct hostent *hp;struct in_addr myaddr;
	char* tHost = ""trustme.example.com"";
	myaddr.s_addr=inet_addr(ip_addr_string);
	hp = gethostbyaddr((char *) &myaddr, sizeof(struct in_addr), AF_INET);
	if (hp && !strncmp(hp->h_name, tHost, sizeof(tHost))) {
		trusted = true;
	} else {
		trusted = false;
	}
```",NULL
807,DX-93,3,NULL,Bad,Java,"```
	String ip = request.getRemoteAddr();
	InetAddress addr = InetAddress.getByName(ip);
	if (addr.getCanonicalHostName().endsWith(""trustme.com"")) {
		trusted = true;
	}
```",NULL
807,DX-93,4,NULL,Bad,C#,"```
	IPAddress hostIPAddress = IPAddress.Parse(RemoteIpAddress);
	IPHostEntry hostInfo = Dns.GetHostByAddress(hostIPAddress);
	if (hostInfo.HostName.EndsWith(""trustme.com"")) {
		trusted = true;
	}
```",NULL
807,DX-93,5,NULL,NULL,NULL,NULL,"IP addresses are more reliable than DNS names, but they can also be spoofed. Attackers can easily forge the source IP address of the packets they send, but response packets will return to the forged IP address. To see the response packets, the attacker has to sniff the traffic between the victim machine and the forged IP address. In order to accomplish the required sniffing, attackers typically attempt to locate themselves on the same subnet as the victim machine. Attackers may be able to circumvent this requirement by using source routing, but source routing is disabled across much of the Internet today. In summary, IP address verification can be a useful part of an authentication scheme, but it should not be the single factor required for authentication."
