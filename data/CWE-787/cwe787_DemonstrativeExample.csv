cwe_id,example_id,entry_order,IntroText,Nature,Language,ExampleCode,BodyText
787,GEN-1,1,The following code attempts to save four different identification numbers into an array.,NULL,NULL,NULL,NULL
787,GEN-1,2,NULL,Bad,C,"```
	int id_sequence[3];
	/* Populate the id array. */
	id_sequence[0] = 123;
	id_sequence[1] = 234;
	id_sequence[2] = 345;
	id_sequence[3] = 456;
```",NULL
787,GEN-1,3,NULL,NULL,NULL,NULL,"Since the array is only allocated to hold three elements, the valid indices are 0 to 2; so, the assignment to id_sequence[3] is out of bounds."
787,DX-114,1,"In the following code, it is possible to request that memcpy move a much larger segment of memory than assumed:",NULL,NULL,NULL,NULL
787,DX-114,2,NULL,Bad,C,"```
	int returnChunkSize(void *) {
```
/* if chunk info is valid, return the size of usable memory,* 
			
			
			 ** else, return -1 to indicate an error* 
			
			
			 **/* 
			...}
	int main() {
	```
		...
		memcpy(destBuf, srcBuf, (returnChunkSize(destBuf)-1));
		...
	}
```",NULL
787,DX-114,3,NULL,NULL,NULL,NULL,"If returnChunkSize() happens to encounter an error it will return -1. Notice that the return value is not checked before the memcpy operation (CWE-252), so -1 can be passed as the size argument to memcpy() (CWE-805). Because memcpy() assumes that the value is unsigned, it will be interpreted as MAXINT-1 (CWE-195), and therefore will copy far more memory than is likely available to the destination buffer (CWE-787, CWE-788)."
787,DX-1,1,This code takes an IP address from the user and verifies that it is well formed. It then looks up the hostname and copies it into a buffer.,NULL,NULL,NULL,NULL
787,DX-1,2,NULL,Bad,C,"```
	void host_lookup(char *user_supplied_addr){
			struct hostent *hp;
			in_addr_t *addr;
			char hostname[64];
			in_addr_t inet_addr(const char *cp);
```
/*routine that ensures user_supplied_addr is in the right format for conversion */* 
			
			validate_addr_form(user_supplied_addr);
			addr = inet_addr(user_supplied_addr);
			hp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);
			strcpy(hostname, hp->h_name);}",NULL
787,DX-1,3,NULL,NULL,NULL,NULL,"This function allocates a buffer of 64 bytes to store the hostname. However, there is no guarantee that the hostname will not be larger than 64 bytes. If an attacker specifies an address which resolves to a very large hostname, then the function may overwrite sensitive data or even relinquish control flow to the attacker."
787,DX-1,4,NULL,NULL,NULL,NULL,Note that this example also contains an unchecked return value (CWE-252) that can lead to a NULL pointer dereference (CWE-476).
787,DX-19,1,This code applies an encoding procedure to an input string and stores it into a buffer.,NULL,NULL,NULL,NULL
787,DX-19,2,NULL,Bad,C,"```
	char * copy_input(char *user_supplied_string){
			int i, dst_index;
			char *dst_buf = (char*)malloc(4*sizeof(char) * MAX_SIZE);
			if ( MAX_SIZE <= strlen(user_supplied_string) ){
				die(""user string too long, die evil hacker!"");
			}
			dst_index = 0;
			for ( i = 0; i < strlen(user_supplied_string); i++ ){
					if( '&' == user_supplied_string[i] ){
						dst_buf[dst_index++] = '&';
						dst_buf[dst_index++] = 'a';
						dst_buf[dst_index++] = 'm';
						dst_buf[dst_index++] = 'p';
						dst_buf[dst_index++] = ';';
					}
					else if ('<' == user_supplied_string[i] ){
```
/* encode to &lt; */* 
							}
					else dst_buf[dst_index++] = user_supplied_string[i];}
			return dst_buf;}",NULL
787,DX-19,3,NULL,NULL,NULL,NULL,"The programmer attempts to encode the ampersand character in the user-controlled string. However, the length of the string is validated before the encoding procedure is applied. Furthermore, the programmer assumes encoding expansion will only expand a given character by a factor of 4, while the encoding of the ampersand expands by 5. As a result, when the encoding procedure expands the string it is possible to overflow the destination buffer if the attacker provides a string of many ampersands."
787,DX-87,1,"In the following C/C++ code, a utility function is used to trim trailing whitespace from a character string. The function copies the input string to a local character string and uses a while statement to remove the trailing whitespace by moving backward through the string and overwriting whitespace with a NUL character.",NULL,NULL,NULL,NULL
787,DX-87,2,NULL,Bad,C,"```
	char* trimTrailingWhitespace(char *strMessage, int length) {
			char *retMessage;
			char *message = malloc(sizeof(char)*(length+1));
```
// copy input string to a temporary string* 
			char message[length+1];
			int index;
			for (index = 0; index < length; index++) {
			```
				message[index] = strMessage[index];
			}
			message[index] = '\0';
```
// trim trailing whitespace* 
			int len = index-1;
			while (isspace(message[len])) {
			```
				message[len] = '\0';
				len--;
			}
```
// return string without trailing whitespace* 
			retMessage = message;
			return retMessage;}",NULL
787,DX-87,3,NULL,NULL,NULL,NULL,"However, this function can cause a buffer underwrite if the input character string contains all whitespace. On some systems the while statement will move backwards past the beginning of a character string and will call the isspace() function on an address outside of the bounds of the local buffer."
787,DX-20,1,"The following code allocates memory for a maximum number of widgets. It then gets a user-specified number of widgets, making sure that the user does not request too many. It then initializes the elements of the array using InitializeWidget(). Because the number of widgets can vary for each request, the code inserts a NULL pointer to signify the location of the last widget.",NULL,NULL,NULL,NULL
787,DX-20,2,NULL,Bad,C,"```
	int i;
	unsigned int numWidgets;
	Widget **WidgetList;
	numWidgets = GetUntrustedSizeValue();
	if ((numWidgets == 0) || (numWidgets > MAX_NUM_WIDGETS)) {
		ExitError(""Incorrect number of widgets requested!"");
	}
	WidgetList = (Widget **)malloc(numWidgets * sizeof(Widget *));
	printf(""WidgetList ptr=%p\n"", WidgetList);
	for(i=0; i<numWidgets; i++) {
		WidgetList[i] = InitializeWidget();
	}
	WidgetList[numWidgets] = NULL;
	showWidgets(WidgetList);
```",NULL
787,DX-20,3,NULL,NULL,NULL,NULL,"However, this code contains an off-by-one calculation error (CWE-193). It allocates exactly enough space to contain the specified number of widgets, but it does not include the space for the NULL pointer. As a result, the allocated buffer is smaller than it is supposed to be (CWE-131). So if the user ever requests MAX_NUM_WIDGETS, there is an out-of-bounds write (CWE-787) when the NULL is assigned. Depending on the environment and compilation settings, this could cause memory corruption."
787,DX-88,1,"The following is an example of code that may result in a buffer underwrite. This code is attempting to replace the substring ""Replace Me"" in destBuf with the string stored in srcBuf. It does so by using the function strstr(), which returns a pointer to the found substring in destBuf. Using pointer arithmetic, the starting index of the substring is found.",NULL,NULL,NULL,NULL
787,DX-88,2,NULL,Bad,C,"```
	int main() { 
		...
		 char *result = strstr(destBuf, ""Replace Me"");
		 int idx = result - destBuf;
		 strcpy(&destBuf[idx], srcBuf);
		 ...
	} 
```",NULL
787,DX-88,3,NULL,NULL,NULL,NULL,"In the case where the substring is not found in destBuf, strstr() will return NULL, causing the pointer arithmetic to be undefined, potentially setting the value of idx to a negative number. If idx is negative, this will result in a buffer underwrite of destBuf."
