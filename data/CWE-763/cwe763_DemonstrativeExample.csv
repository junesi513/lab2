cwe_id,example_id,entry_order,IntroText,Nature,Language,ExampleCode,BodyText
763,DX-78,1,"This code attempts to tokenize a string and place it into an array using the strsep function, which inserts a \0 byte in place of whitespace or a tab character. After finishing the loop, each string in the AP array points to a location within the input string.",NULL,NULL,NULL,NULL
763,DX-78,2,NULL,Bad,C,"```
	char **ap, *argv[10], *inputstring;
	for (ap = argv; (*ap = strsep(&inputstring, "" \t"")) != NULL;)
			if (**ap != '\0')
				if (++ap >= &argv[10])
					break;
	/.../
	free(ap[4]);
```",NULL
763,DX-78,3,NULL,NULL,NULL,NULL,"Since strsep is not allocating any new memory, freeing an element in the middle of the array is equivalent to free a pointer in the middle of inputstring."
763,DX-80,1,"This example allocates a BarObj object using the new operator in C++, however, the programmer then deallocates the object using free(), which may lead to unexpected behavior.",NULL,NULL,NULL,NULL
763,DX-80,2,NULL,Bad,C++,"```
	void foo(){
			BarObj *ptr = new BarObj()
```
/* do some work with ptr here */* 
			
			...
			
			free(ptr);}",NULL
763,DX-80,3,NULL,NULL,NULL,NULL,"Instead, the programmer should have either created the object with one of the malloc family functions, or else deleted the object with the delete operator."
763,DX-80,4,NULL,Good,C++,"```
	void foo(){
			BarObj *ptr = new BarObj()
```
/* do some work with ptr here */* 
			
			...
			
			delete ptr;}",NULL
763,DX-77,1,"In this example, the programmer dynamically allocates a buffer to hold a string and then searches for a specific character. After completing the search, the programmer attempts to release the allocated memory and return SUCCESS or FAILURE to the caller. Note: for simplification, this example uses a hard-coded ""Search Me!"" string and a constant string length of 20.",NULL,NULL,NULL,NULL
763,DX-77,2,NULL,Bad,C,"```
	#define SUCCESS (1)
	#define FAILURE (0)
	int contains_char(char c){
			char *str;
			str = (char*)malloc(20*sizeof(char));
			strcpy(str, ""Search Me!"");
			while( *str != NULL){
					if( *str == c ){
```
/* matched char, free string and return success */* 
							free(str);
							return SUCCESS;}
					
					 */* didn't match yet, increment pointer and try next char */* 
					
					str = str + 1;}
			
			 */* we did not match the char in the string, free mem and return failure */* 
			
			free(str);
			return FAILURE;}",NULL
763,DX-77,3,NULL,NULL,NULL,NULL,"However, if the character is not at the beginning of the string, or if it is not in the string at all, then the pointer will not be at the start of the buffer when the programmer frees it."
763,DX-77,4,NULL,NULL,NULL,NULL,"Instead of freeing the pointer in the middle of the buffer, the programmer can use an indexing pointer to step through the memory or abstract the memory calculations by using array indexing."
763,DX-77,5,NULL,Good,C,"```
	#define SUCCESS (1)
	#define FAILURE (0)
	int cointains_char(char c){
			char *str;
			int i = 0;
			str = (char*)malloc(20*sizeof(char));
			strcpy(str, ""Search Me!"");
			while( i < strlen(str) ){
					if( str[i] == c ){
```
/* matched char, free string and return success */* 
							free(str);
							return SUCCESS;}
					
					 */* didn't match yet, increment pointer and try next char */* 
					
					i = i + 1;}
			
			 */* we did not match the char in the string, free mem and return failure */* 
			
			free(str);
			return FAILURE;}",NULL
763,DX-79,1,"Consider the following code in the context of a parsing application to extract commands out of user data. The intent is to parse each command and add it to a queue of commands to be executed, discarding each malformed entry.",NULL,NULL,NULL,NULL
763,DX-79,2,NULL,Bad,C,"```
```
//hardcode input length for simplicity* 
	char* input = (char*) malloc(40*sizeof(char));
	char *tok;
	char* sep = "" \t"";
	
	get_user_input( input );
	
	
	 */* The following loop will parse and process each token in the input string */* 
	
	tok = strtok( input, sep);
	while( NULL != tok ){
	```
			if( isMalformed( tok ) ){
```
/* ignore and discard bad data */* 
					free( tok );}
			else{
			```
				add_to_command_queue( tok );
			}
			tok = strtok( NULL, sep));
	}
```",NULL
763,DX-79,3,NULL,NULL,NULL,NULL,"While the above code attempts to free memory associated with bad commands, since the memory was all allocated in one chunk, it must all be freed together."
763,DX-79,4,NULL,NULL,NULL,NULL,"One way to fix this problem would be to copy the commands into a new memory location before placing them in the queue. Then, after all commands have been processed, the memory can safely be freed."
763,DX-79,5,NULL,Good,C,"```
```
//hardcode input length for simplicity* 
	char* input = (char*) malloc(40*sizeof(char));
	char *tok, *command;
	char* sep = "" \t"";
	
	get_user_input( input );
	
	
	 */* The following loop will parse and process each token in the input string */* 
	
	tok = strtok( input, sep);
	while( NULL != tok ){
	```
			if( !isMalformed( command ) ){
```
/* copy and enqueue good data */* 
					command = (char*) malloc( (strlen(tok) + 1) * sizeof(char) );
					strcpy( command, tok );
					add_to_command_queue( command );}
			tok = strtok( NULL, sep));}
	
	free( input )",NULL
