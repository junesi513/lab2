[
    {
        "example_id": "DX-27",
        "fixed_code": "\"my $dataPath = \"/users/cwe/profiles\";\\nmy $username = param(\"user\");\\nif($username=~ m/[^a-zA-Z0-9]/) { ExitError(\"Invalid characters in username.\"); }\\nmy $profilePath = $dataPath . \"/\" . $username;\\nopen(my $fh, \"<\", $profilePath) || ExitError();\\nprint \"<ul>\\n\";\\nwhile (<$fh>) {\\n\\tprint \"<li>\".encode_entities($_).\"</li>\\n\";\\n}\\nprint \"</ul>\\n\";\"",
        "description": "\"The original code has a path traversal vulnerability where the user input is directly used to access a file without validating the input. This could allow an attacker to access files outside the intended directory by using '../' in the input to go up directory levels. To fix this, a regular expression is used to validate the username ensuring it only contains alphanumeric characters, preventing directory traversal.\\nAnother vulnerability in the original code is potential XSS (Cross-Site Scripting) through the output of file contents. An attacker can craft a user profile to include HTML or JavaScript code that would be executed in the victim's browser when viewing that profile. This can be mitigated by encoding the output using a function like 'encode_entities' that replaces characters with their HTML entity counterparts, thus preventing any HTML or JavaScript code from being executed.\\nLastly, the original code included potentially sensitive information in its error message (the file path). This is mitigated in the fixed code by making the error message generic, not giving away any potentially sensitive system information.\""
    },
    {
        "example_id": "DX-18",
        "error": "Failed to parse JSON: Expecting ',' delimiter: line 4 column 129 (char 472)",
        "raw_response": "{\n  \"example_id\": \"DX-18\",\n  \"fixed_code\": \"String filename = System.getProperty(\\\"com.domain.application.dictionaryFile\\\");\\nif (filename == null || filename.contains(\\\"..\\\")) {\\n  throw new IllegalArgumentException(\\\"Invalid dictionary filename.\\\");\\n}\\nFile dictionaryFile = new File(applicationHomeDirectory + File.separator + filename);\",\n  \"description\": \"The vulnerability allows for Path Traversal attacks because the code doesn't verify if the filename contains \"..\" which denotes a parent directory. An attacker can input a filename like '../../../etc/passwd' to navigate to sensitive directories. Additionally, the filename can be null leading to a NullPointerException when a File object is created. The fix includes validation before creating the File object. When the filename is either null or contains directory traversal sequences, an IllegalArgumentException is thrown. Finally, the filename is appended to a known safe directory path (represented by the variable applicationHomeDirectory) using the File.separator to ensure the File object is created in a controlled, tied-to-application location.\"\n}"
    },
    {
        "example_id": "DX-2",
        "fixed_code": "{\\n\\tmy $Username = GetUntrustedInput();\\n\\t$Username =~ s/\\.\\.\\///g;\\n\\tmy $filename = \"/home/user/\" . $Username;\\n\\tReadAndSendFile($filename);\\n}",
        "description": "The vulnerability in the code is due to the regular expression only removing the first instance of '../' from the username instead of all occurrences. This allows a potential attacker to use relative path traversal (CWE-23) to access confidential files by just adding additional '../' to the input. The fixed code uses the /g (global match) modifier in the regular expression to ensure that all occurrences of '../' are removed from the user input. The /g modifier means to continue matching (and replacing) after the first match, not stopping at the first match. This does not completely remove the vulnerability of path traversal, but it reduces the risk. However, using user-supplied inputs to access file paths always opens a possible avenue for exploitation. The program should also add checks to validate user entries, restrict access permissions, and use safe library functions to concatenate paths."
    },
    {
        "example_id": "GEN-4",
        "fixed_code": "\"String path = getInputPath();\\ntry {\\n    File validatedPath = new File(path).getCanonicalFile();\\n    if(validatedPath.getPath().startsWith('/safe_dir/')) {\\n        if(validatedPath.exists()) {\\n            validatedPath.delete();\\n        }\\n    }\\n} catch (IOException e) {\\n    e.printStackTrace();\\n}\n\"",
        "description": "\"The vulnerability in the initial code lies in the fact that the path starts with '\\/safe_dir\\/' and is hence considered valid. However, paths such as '\\/safe_dir\\/..\\/important.dat' can be used to get the program to delete important files from the parent directory. This type of vulnerability is known as Path Traversal.\\n\\nIn the fixed code, we first create a File object with the obtained path and then call the getCanonicalFile() method. This function resolves the input path to an absolute path, thus eliminating possible '../' or any such relative paths from the input which could potentially lead to illegal file access. Then, we check if the created file path starts with safe_dir. If it does, and if the file exists, then the file is deleted. We also catch any IOException that might occur during these operations.\\nThis way, we ensure that any relative paths are absolutely resolved and hence prevent Path Traversal attacks.\""
    },
    {
        "example_id": "DX-22",
        "fixed_code": "\"public class FileUploadServlet extends HttpServlet {\\n...\\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\\nresponse.setContentType(\\\"text/html\\\");\\nPrintWriter out = response.getWriter();\\nString contentType = request.getContentType();\\n// the starting position of the boundary header\\nint ind = contentType.indexOf(\\\"boundary=\\\");\\nString boundary = contentType.substring(ind+9);\\n//Path traversal and filetype check \\nfinal Path UPLOAD_PATH = Paths.get(UPLOAD_DIRECTORY_STRING);\\n// verify that content type is multipart form data\\nif (contentType != null && contentType.indexOf(\\\"multipart/form-data\\\") != -1) {\\n// extract the filename from the Http header\\nBufferedReader br = new BufferedReader(new InputStreamReader(request.getInputStream()));\\n...\\npLine = br.readLine();\\nString fileName = pLine.substring(pLine.lastIndexOf(\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\"), pLine.lastIndexOf(\\\\\\\"\\\\\\\\\\\\\\\\\\\"));\\n// Sanitize filename from any path traversal sequences \\nPath filePath = Paths.get(fileName);\\nPath resolvedPath = UPLOAD_PATH.resolve(filePath.getFileName().toString());\\n// check on the type of the file being uploaded\\nString ext = Files.probeContentType(resolvedPath); \\nif (!(ext.equals(\\\"image/png\\\") || ext.equals(\\\"image/jpeg\\\"))) { ... }\\n// output the file to the local upload directory\\ntry {\\nBufferedWriter bw = new BufferedWriter(new FileWriter(resolvedPath.toString(), true));\\nfor (String line; (line=br.readLine())!=null; ) {\\nif (line.indexOf(boundary) == -1) {\\nbw.write(line);\\nbw.newLine();\\nbw.flush();\\n}\\n} //end of for loop\\nbw.close();\\n} catch (IOException ex) {...}\\n// output successful upload response HTML page\\n}\\n// output unsuccessful upload response HTML page\\nelse\\n{...}\\n}\\n...\\n}\",",
        "description": "\"This code had two main vulnerabilities. The first was unrestricted file upload, which could allow an attacker to upload any executable file or other files with malicious codes. To fix this, I added file type check to only allow desired file types (i.e., .png or .jpeg in this case) to be uploaded. The second vulnerability was relative path traversal, which allowed the attacker to traverse directories out of the desired directory using '../' sequences. To address this, I extracted only the filename from the supplied path, and resolved against the UPLOAD_DIRECTORY_STRING which prevents any directory traversals. This fixes the possibility to specify arbitrary files to write to, leading to wide variety of consequences like code execution, XSS or system crash.\""
    },
    {
        "example_id": "DX-159",
        "fixed_code": "{\\n\\timport os\\n\\timport sys\\n\\tdef main():\\n\\t\\tfilename = sys.argv[1]\\n\\t\\tpath = os.path.normpath(f\\\"{os.getcwd()}{os.sep}{filename}\\\")\\n\\t\\tif path.startswith(\\\"/home/cwe/documents/\\\"):\\n\\t\\t\\ttry:\\n\\t\\t\\t\\twith open(path, 'r') as f:\\n\\t\\t\\t\\t\\tfile_data = f.read()\\n\\t\\t\\texcept FileNotFoundError as e:\\n\\t\\t\\t\\tprint(\\\"Error - file not found\\\")\\n\\tmain() \\n\\n}",
        "description": "The original code had a vulnerability where if the user supplied an absolute path, the os.path.join() function discarded the path to the current working directory and used only the absolute path provided. This means, an attacker could cause the script to access and read files outside the intended directory, leading to a potential information exposure. In the corrected code: \\n- Firstly, the os.sep is used add the appropriate separation character depending on the OS, thereby helping with cross-platform compatibility.\\n- Then, the function os.path.normpath() is used to remove additional slashes that may have been provided by the user. This helps minimize potential issues arising out of path manipulation.\\n- Additionally, checks have been added where the final path is made to start with the intended directory /home/cwe/documents/. This ensures the routines are run only within the designated directory, thus limiting the scope of file access and mitigating the risk of arbitrary file read access by potential attackers."
    }
]