cwe_id,example_id,entry_order,IntroText,Nature,Language,ExampleCode,BodyText
788,DX-1,1,"This example takes an IP address from a user, verifies that it is well formed and then looks up the hostname and copies it into a buffer.",NULL,NULL,NULL,NULL
788,DX-1,2,NULL,Bad,C,"```
	void host_lookup(char *user_supplied_addr){
			struct hostent *hp;
			in_addr_t *addr;
			char hostname[64];
			in_addr_t inet_addr(const char *cp);
```
/*routine that ensures user_supplied_addr is in the right format for conversion */* 
			
			validate_addr_form(user_supplied_addr);
			addr = inet_addr(user_supplied_addr);
			hp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);
			strcpy(hostname, hp->h_name);}",NULL
788,DX-1,3,NULL,NULL,NULL,NULL,"This function allocates a buffer of 64 bytes to store the hostname, however there is no guarantee that the hostname will not be larger than 64 bytes. If an attacker specifies an address which resolves to a very large hostname, then the function may overwrite sensitive data or even relinquish control flow to the attacker."
788,DX-1,4,NULL,NULL,NULL,NULL,Note that this example also contains an unchecked return value (CWE-252) that can lead to a NULL pointer dereference (CWE-476).
788,DX-114,1,"In the following example, it is possible to request that memcpy move a much larger segment of memory than assumed:",NULL,NULL,NULL,NULL
788,DX-114,2,NULL,Bad,C,"```
	int returnChunkSize(void *) {
```
/* if chunk info is valid, return the size of usable memory,* 
			
			
			 ** else, return -1 to indicate an error* 
			
			
			 **/* 
			...}
	int main() {
	```
		...
		memcpy(destBuf, srcBuf, (returnChunkSize(destBuf)-1));
		...
	}
```",NULL
788,DX-114,3,NULL,NULL,NULL,NULL,"If returnChunkSize() happens to encounter an error it will return -1. Notice that the return value is not checked before the memcpy operation (CWE-252), so -1 can be passed as the size argument to memcpy() (CWE-805). Because memcpy() assumes that the value is unsigned, it will be interpreted as MAXINT-1 (CWE-195), and therefore will copy far more memory than is likely available to the destination buffer (CWE-787, CWE-788)."
788,DX-19,1,This example applies an encoding procedure to an input string and stores it into a buffer.,NULL,NULL,NULL,NULL
788,DX-19,2,NULL,Bad,C,"```
	char * copy_input(char *user_supplied_string){
			int i, dst_index;
			char *dst_buf = (char*)malloc(4*sizeof(char) * MAX_SIZE);
			if ( MAX_SIZE <= strlen(user_supplied_string) ){
				die(""user string too long, die evil hacker!"");
			}
			dst_index = 0;
			for ( i = 0; i < strlen(user_supplied_string); i++ ){
					if( '&' == user_supplied_string[i] ){
						dst_buf[dst_index++] = '&';
						dst_buf[dst_index++] = 'a';
						dst_buf[dst_index++] = 'm';
						dst_buf[dst_index++] = 'p';
						dst_buf[dst_index++] = ';';
					}
					else if ('<' == user_supplied_string[i] ){
```
/* encode to &lt; */* 
							}
					else dst_buf[dst_index++] = user_supplied_string[i];}
			return dst_buf;}",NULL
788,DX-19,3,NULL,NULL,NULL,NULL,"The programmer attempts to encode the ampersand character in the user-controlled string, however the length of the string is validated before the encoding procedure is applied. Furthermore, the programmer assumes encoding expansion will only expand a given character by a factor of 4, while the encoding of the ampersand expands by 5. As a result, when the encoding procedure expands the string it is possible to overflow the destination buffer if the attacker provides a string of many ampersands."
788,DX-91,1,"In the following C/C++ example the method processMessageFromSocket() will get a message from a socket, placed into a buffer, and will parse the contents of the buffer into a structure that contains the message length and the message body. A for loop is used to copy the message body into a local character string which will be passed to another method for processing.",NULL,NULL,NULL,NULL
788,DX-91,2,NULL,Bad,C,"```
	int processMessageFromSocket(int socket) {
			int success;
			char buffer[BUFFER_SIZE];
			char message[MESSAGE_SIZE];
```
// get message from socket and store into buffer* 
			
			
			 *//Ignoring possibliity that buffer > BUFFER_SIZE* 
			if (getMessage(socket, buffer, BUFFER_SIZE) > 0) {
			```
```
// place contents of the buffer into message structure* 
					ExMessage *msg = recastBuffer(buffer);
					
					
					 *// copy message body into string for processing* 
					int index;
					for (index = 0; index < msg->msgLength; index++) {
					```
						message[index] = msg->msgBody[index];
					}
					message[index] = '\0';
```
// process message* 
					success = processMessage(message);}
			return success;}",NULL
788,DX-91,3,NULL,NULL,NULL,NULL,"However, the message length variable from the structure is used as the condition for ending the for loop without validating that the message length variable accurately reflects the length of the message body (CWE-606). This can result in a buffer over-read (CWE-125) by reading from memory beyond the bounds of the buffer if the message length variable indicates a length that is longer than the size of a message body (CWE-130)."
