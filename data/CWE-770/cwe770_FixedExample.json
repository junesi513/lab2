[
    {
        "example_id": "DX-25",
        "fixed_code": "#include <sys/socket.h>\\n#include <stdio.h>\\n#include <unistd.h>\\n\\n#define MAX_CONNECTIONS 100 \\n\\nint main() {\\n\\n  int sock, newsock, count = 0;\\n  pid_t pid;\\n\\n  sock=socket(AF_INET, SOCK_STREAM, 0);\\n  while (1) {\\n    if (count > MAX_CONNECTIONS) {\\n      printf(\\\"Maximum connections limit reached.\\n\\\");\\n      return 0;\\n    }\\n    newsock=accept(sock, ...);\\n    printf(\\\"A connection has been accepted\\n\\\");\\n    pid = fork();\\n    if (pid == 0) {\\n      close(sock);\\n    } else {\\n      close(newsock);\\n      ++count;\\n    }\\n  }\\n  return 0;\\n}",
        "description": "The major problem was that the program did not track how many connections had been made, nor did it limit the number of connections it could create. Because the fork operation is quite resource-intensive, a hacker could easily exhaust system resources such as the CPU, processes, and memory by creating a large number of connections, or consume all available connections, thereby blocking lawful users from remotely accessing the system. To fix the vulnerability, a counter (`count`) was introduced to keep track of the number of connections. If `MAX_CONNECTIONS` is exceeded, an error message is displayed and the program stops accepting new connections. After a connection is established, the parent process closes the newly accepted socket using `close(newsock)`, while child process closes the 'listen' socket using `close(sock)`. This way, each process only has the socket it needs, which avoids inadvertent socket sharing which could be another potential vulnerability."
    },
    {
        "example_id": "DX-50",
        "fixed_code": "int writeDataFromSocketToFile(char *host, int port, long size_limit)\n{\n\tchar filename[FILENAME_SIZE];\n\tchar buffer[BUFFER_SIZE];\n\tlong total_bytes_written = 0;\n\tint socket = openSocketConnection(host, port);\n\tif (socket < 0) {\n\t\tprintf(\"Unable to open socket connection\");\n\t\treturn(FAIL);\n\t}\n\tif (getNextMessage(socket, filename, FILENAME_SIZE) > 0) {\n\t\t\tif (openFileToWrite(filename) > 0) {\n\t\t\t\twhile (total_bytes_written < size_limit && getNextMessage(socket, buffer, BUFFER_SIZE) > 0){\n\t\t\t\t\tif (!(writeToFile(buffer) > 0))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\ttotal_bytes_written += strlen(buffer);\n\t\t\t\t}\n\t\t\t}\n\t\tcloseFile();\n\t}\n\tcloseSocket(socket);\n}",
        "description": "The vulnerability in the given code is that it does not have any limit to the size of the data that can be written to the file. This can potentially lead to resource exhaustion and denial of service whereby all the available disk space is consumed.\n\nThe fix addresses this issue by introducing a size limit to the data that can be written to the file. A variable total_bytes_written is used to keep track of the total bytes that have been written to the file. Inside the while block, after each successful writeToFile operation, the amount of written bytes (the length of the buffer) is added to total_bytes_written. The while loop condition is also modified to stop writing data into the file when the total_bytes_written have reached the size_limit. This prevents the writing operation from consuming all the available space in the disk."
    },
    {
        "example_id": "DX-51",
        "fixed_code": "\"unsigned int processMessage(char **message) {\\n\\tchar *body;\\n\\tunsigned int length = getMessageLength(message[0]);\\n\\tif ((length > 0) && (length < MAX_LENGTH)) {\\n\\t\\tbody = &message[1][0];\\n\\t\\tprocessMessageBody(body);\\n\\t\\treturn(SUCCESS);\\n\\t} else {\\n\\t\\tprintf(\\\"Unable to process message; invalid message length\\\");\\n\\t\\treturn(FAIL);\\n\\t}\\n}\"",
        "description": "The vulnerability in the code originates from the lack of a maximum boundary check for the length of the message body. This can result in excessive memory consumption, especially when the length of the body character array is very large, potentially leading to system resource exhaustion. Moreover, the 'int' datatype can accommodate negative values. In context, negative length values could lead to errors. The fix addresses these issues by adding a condition to check that the length of the message body is less than a defined maximum length 'MAX_LENGTH', and changing the datatype of 'length' from 'int' to 'unsigned int'. The 'unsigned int' type ensures that 'length' is always a non-negative number, eliminating issues arising from potential negative length values."
    },
    {
        "example_id": "DX-52",
        "fixed_code": "{\n\t\"public static final int SERVER_PORT = 4444;\",\n\t\"public static final int MAX_CONNECTIONS = 10;\",\n\t\"...\",\n\t\"public void acceptConnections() {\",\n\t\t\"try {\",\n\t\t\t\"ServerSocket serverSocket = new ServerSocket(SERVER_PORT);\",\n\t\t\t\"int counter = 0;\",\n\t\t\t\"boolean hasConnections = true;\",\n\t\t\t\"while (hasConnections) {\",\n\t\t\t\t\"hasConnections = checkForMoreConnections();\",\n\t\t\t\t\"Socket client = serverSocket.accept();\",\n\t\t\t\t\"Thread t = new Thread(new ClientSocketThread(client));\",\n\t\t\t\t\"t.setName(client.getInetAddress().getHostName() + \\\":\\\" + counter++);\",\n\t\t\t\t\"ExecutorService pool = Executors.newFixedThreadPool(MAX_CONNECTIONS);\",\n\t\t\t\t\"pool.execute(t);\",\n\t\t\t\"}\",\n\t\t\t\"serverSocket.close();\",\n\t\t\"} catch (IOException ex) {...}\",\n\t\"}\",\n\"}\"",
        "description": "The issue in the initial code sample is that it allows for an unlimited number of client connections and threads to be created. This could potentially overwhelm the system's resources. The fixed code addresses this problem by introducing a limitation on the number of client connections and threads that can be created. This is achieved by using a thread pool `ExecutorService` that is initialized with a maximum number of allowable threads (`MAX_CONNECTIONS`). Furthermore, it includes a check to break the loop when no more connections are needed or allowed (`checkForMoreConnections()`). This way, the system can better manage the resources, preventing the exhausting of system resources and potential denial of service."
    },
    {
        "example_id": "GEN-5",
        "fixed_code": "function purchaseTickets(event_id, user_id, count) {\\n  if (count > 10) {\\n    return new Error('Cannot purchase more than 10 tickets.');\\n  }\\n  \\n  return handlePurchase(event_id, user_id, count);\\n}",
        "description": "The original code didn't have any limit for the number of tickets that can be purchased by a single user. This can be exploited to buy more tickets than allowed, blocking others from purchasing. The vulnerability is fixed by adding a conditional check on the 'count' variable. If 'count' exceeds 10, the function will now terminate and return an error message. Otherwise, it will proceed to handle the purchase as intended."
    },
    {
        "example_id": "GEN-6",
        "fixed_code": "{\\n\\tbar connection() {\\n\\t\\tfoo = malloc(1024);\\n\\t\\treturn foo;\\n\\t}\\n\\tendConnection(bar foo) {\\n\\t\\tfree(foo);\\n\\t}\\n\\tint main() {\\n\\t\\twhile(1) {\\n\\t\\t\\tfoo=connection();\\n\\t\\t\\tendConnection(foo);\\n\\t\\t}\\n\\t}\\n}",
        "description": "The problematic code is in the main() function where it continuously creates a new connection within an infinite loop causing it to use up all the available memory slowly. However, after creating the connection it doesn't free up the memory meaning that every new connection adds to memory usage without restricting its memory footprint and eventually leading it to consume all the available memory (creating memory leak).\\n\\nThis issue is fixed in the corrected code by ensuring that we free up the memory using the endConnection() function after each creation of a new connection inside the while loop. This will prevent memory leak by making sure that previously allocated memory is released before creating a new connection."
    }
]